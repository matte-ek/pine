#include <fmt/format.h>
#include "AssetPropertiesRenderer.hpp"

#include <imgui_internal.h>

#include "IconsMaterialDesign.h"
#include "imgui.h"

#include "Gui/Shared/IconStorage/IconStorage.hpp"
#include "Gui/Shared/Widgets/Widgets.hpp"
#include "Pine/Assets/Tilemap/Tilemap.hpp"
#include "Pine/Assets/Tileset/Tileset.hpp"
#include "Gui/Panels/AssetBrowser/AssetBrowserPanel.hpp"
#include "Gui/Shared/Selection/Selection.hpp"
#include "Pine/Assets/Material/Material.hpp"
#include "Pine/Assets/Model/Model.hpp"
#include "Pine/Assets/Texture3D/Texture3D.hpp"
#include "Pine/Assets/Blueprint/Blueprint.hpp"
#include "Pine/Assets/Level/Level.hpp"
#include "Pine/Assets/AudioFile/AudioFile.hpp"
#include "Pine/Assets/Assets.hpp"
#include "Gui/Panels/Properties/EntityPropertiesRenderer/EntityPropertiesRenderer.hpp"
#include "Pine/Rendering/Rendering.hpp"
#include "Pine/World/World.hpp"

namespace
{

    void RenderTexture2D(const Pine::Texture2D *texture2d)
    {
        const auto textureAspectRatio = static_cast<float>(texture2d->GetWidth()) / static_cast<float>(texture2d->GetHeight());
        const auto previewWidth = ImGui::GetContentRegionAvail().x * 0.5f;
        const auto previewHeight = previewWidth / textureAspectRatio;

        ImGui::Image(reinterpret_cast<ImTextureID>(*static_cast<std::uint64_t *>(texture2d->GetGraphicsTexture()->GetGraphicsIdentifier())), ImVec2(previewWidth, previewHeight));

        ImGui::Text("Width: %d", texture2d->GetWidth());
        ImGui::Text("Height: %d", texture2d->GetHeight());
        ImGui::Text("Format: %s", Pine::Graphics::TextureFormatToString(texture2d->GetFormat()));
        ImGui::Text("Has mip-maps: %s", texture2d->GetGenerateMipmaps() ? "true" : "false");
    }

    void RenderTexture3D(Pine::Texture3D *texture3d)
    {
        ImGui::Text("Valid: %s", texture3d->IsValid() ? "Yes" : "No");

        const auto front = texture3d->GetSideTexture(Pine::TextureCubeSide::Front);
        const auto frontResult = Widgets::AssetPicker("Front", front, Pine::AssetType::Texture2D);

        const auto back = texture3d->GetSideTexture(Pine::TextureCubeSide::Back);
        const auto backResult = Widgets::AssetPicker("Back", back, Pine::AssetType::Texture2D);

        const auto left = texture3d->GetSideTexture(Pine::TextureCubeSide::Left);
        const auto leftResult = Widgets::AssetPicker("Left", left, Pine::AssetType::Texture2D);

        const auto right = texture3d->GetSideTexture(Pine::TextureCubeSide::Right);
        const auto rightResult = Widgets::AssetPicker("Right", right, Pine::AssetType::Texture2D);

        const auto top = texture3d->GetSideTexture(Pine::TextureCubeSide::Top);
        const auto topResult = Widgets::AssetPicker("Top", top, Pine::AssetType::Texture2D);

        const auto bottom = texture3d->GetSideTexture(Pine::TextureCubeSide::Bottom);
        const auto bottomResult = Widgets::AssetPicker("Bottom", bottom, Pine::AssetType::Texture2D);

        if (frontResult.hasResult)
            texture3d->SetSideTexture(Pine::TextureCubeSide::Front, dynamic_cast<Pine::Texture2D *>(frontResult.asset));
        if (backResult.hasResult)
            texture3d->SetSideTexture(Pine::TextureCubeSide::Back, dynamic_cast<Pine::Texture2D *>(backResult.asset));
        if (leftResult.hasResult)
            texture3d->SetSideTexture(Pine::TextureCubeSide::Left, dynamic_cast<Pine::Texture2D *>(leftResult.asset));
        if (rightResult.hasResult)
            texture3d->SetSideTexture(Pine::TextureCubeSide::Right, dynamic_cast<Pine::Texture2D *>(rightResult.asset));
        if (topResult.hasResult)
            texture3d->SetSideTexture(Pine::TextureCubeSide::Top, dynamic_cast<Pine::Texture2D *>(topResult.asset));
        if (bottomResult.hasResult)
            texture3d->SetSideTexture(Pine::TextureCubeSide::Bottom, dynamic_cast<Pine::Texture2D *>(bottomResult.asset));

        if (ImGui::Button("Build"))
        {
            texture3d->Build();
        }
    }

    void RenderShader(Pine::Shader *shader)
    {
    }

    void RenderMaterial(Pine::Material *material)
    {
        if (material->IsMeshGenerated())
        {
            ImGui::Text("This material is generated by a model file, and cannot be edited.");
            ImGui::Spacing();
            Widgets::PushDisabled();
        }

        const auto diffuseResult = Widgets::AssetPicker("Diffuse Map", material->GetDiffuse(), Pine::AssetType::Texture2D);
        const auto specularResult = Widgets::AssetPicker("Specular Map", material->GetSpecular(), Pine::AssetType::Texture2D);
        const auto normalResult = Widgets::AssetPicker("Normal Map", material->GetNormal(), Pine::AssetType::Texture2D);

        if (diffuseResult.hasResult)
            material->SetDiffuse(dynamic_cast<Pine::Texture2D *>(diffuseResult.asset));
        if (specularResult.hasResult)
            material->SetSpecular(dynamic_cast<Pine::Texture2D *>(specularResult.asset));
        if (normalResult.hasResult)
            material->SetNormal(dynamic_cast<Pine::Texture2D *>(normalResult.asset));

        auto diffuseColor = material->GetDiffuseColor();
        if (Widgets::ColorPicker3("Diffuse Color", diffuseColor))
            material->SetDiffuseColor(diffuseColor);

        auto specularColor = material->GetSpecularColor();
        if (Widgets::ColorPicker3("Specular Color", specularColor))
            material->SetSpecularColor(specularColor);

        auto ambientColor = material->GetAmbientColor();
        if (Widgets::ColorPicker3("Ambient Color", ambientColor))
            material->SetAmbientColor(ambientColor);

        const auto shaderResult = Widgets::AssetPicker("Shader", material->GetShader(), Pine::AssetType::Shader);
        if (shaderResult.hasResult)
            material->SetShader(dynamic_cast<Pine::Shader *>(shaderResult.asset));

        auto shininess = material->GetShininess();
        if (Widgets::SliderFloat("Shininess", &shininess, 0.f, 128.f))
            material->SetShininess(shininess);

        auto textureScale = material->GetTextureScale();
        if (Widgets::SliderFloat("Texture Scale", &textureScale, 0.f, 32.f))
            material->SetTextureScale(textureScale);

        auto renderMode = static_cast<int>(material->GetRenderingMode());
        if (Widgets::Combobox("Rendering Mode", &renderMode, "Opaque\0Discard\0Transparent\0"))
            material->SetRenderingMode(static_cast<Pine::MaterialRenderingMode>(renderMode));

        if (material->IsMeshGenerated())
        {
            Widgets::PopDisabled();
        }
    }

    void RenderModel(Pine::Model *model)
    {
        for (int i = 0; i < model->GetMeshes().size();i++)
        {
            auto mesh = model->GetMeshes()[i];
;
            if (ImGui::CollapsingHeader(fmt::format("Mesh {}", i).c_str(), ImGuiTreeNodeFlags_DefaultOpen))
            {
                ImGui::Text("Render Count: %d", mesh->GetRenderCount());
                ImGui::Text("Has Element Buffer: %s", mesh->HasElementBuffer() ? "Yes" : "No");
                ImGui::Text("AABB Mins: (%f, %f, %f)", mesh->GetBoundingBoxMin().x, mesh->GetBoundingBoxMin().y, mesh->GetBoundingBoxMin().z);
                ImGui::Text("AABB Maxs: (%f, %f, %f)", mesh->GetBoundingBoxMax().x, mesh->GetBoundingBoxMax().y, mesh->GetBoundingBoxMax().z);

                const auto newMaterial = Widgets::AssetPicker("Material", std::to_string(i), mesh->GetMaterial(), Pine::AssetType::Material);
                if (newMaterial.hasResult)
                {
                    mesh->SetMaterial(dynamic_cast<Pine::Material *>(newMaterial.asset));
                }

                if (mesh->GetMaterial() && mesh->GetMaterial()->IsMeshGenerated())
                {
                    ImGui::Spacing();
                    ImGui::TextDisabled("The material is generated by the model file, and cannot be edited. However you");
                    ImGui::TextDisabled("can generate a material based on the generated one, and edit that.");
                    ImGui::Spacing();

                    if (ImGui::Button("Generate Custom Material", ImVec2(180.f, 35.f)))
                    {
                        auto material = mesh->GetMaterial();
                        const auto modelDirectory = std::filesystem::path(model->GetFilePath()).parent_path().string();

                        material->SetFilePath(fmt::format("{}/{}_Material{}.mat", modelDirectory, std::filesystem::path(model->GetFileName()).stem().string(), i));
                        material->SaveToFile();

                        auto loadedMat = dynamic_cast<Pine::Material*>(Pine::Assets::LoadFromFile(material->GetFilePath(), model->GetFileRootPath().string()));

                        mesh->SetMaterial(loadedMat);

                        Panels::AssetBrowser::RebuildAssetTree();
                    }
                }
            }
        }
    }

    void RenderBlueprint(Pine::Blueprint *blueprint)
    {
        ImGui::Text("Has Entity: %s", blueprint->HasEntity() ? "Yes" : "No");

        ImGui::Spacing();
        ImGui::Separator();
        ImGui::Spacing();

        EntityPropertiesPanel::Render(blueprint->GetEntity());
    }

    void RenderLevel(Pine::Level *level)
    {
        ImGui::Text("Blueprint count: %zu", level->GetBlueprintCount());

        if (ImGui::Button("Load", ImVec2(150.f, 45.f)))
        {
            Pine::World::SetActiveLevel(level);
        }

        ImGui::SameLine();

        if (ImGui::Button("Save", ImVec2(150.f, 45.f)))
        {
            level->CreateFromWorld();
        }
    }

    void RenderTileset(Pine::Tileset *tileset)
    {
        static int selectedTileset = 0;

        int selectedSource = 1;

        ImGui::Text("Source:");

        ImGui::SetNextItemWidth(180.f);

        if (ImGui::Combo("##Source", &selectedSource, "Atlas Texture\0Multiple Textures\0"))
        {
                
        }

        if (selectedSource == 0)
        {
                
        }

        ImGui::Spacing();
        ImGui::Spacing();
        ImGui::Spacing();

        ImGui::Button(ICON_MD_ADD);

        if (ImGui::BeginDragDropTarget())
        {
            if (const auto payload = ImGui::AcceptDragDropPayload("Asset"))
            {
                auto droppedAsset = *static_cast<Pine::IAsset**>(payload->Data);

                if (droppedAsset && droppedAsset->GetType() == Pine::AssetType::Texture2D)
                {
                    auto texture2d = dynamic_cast<Pine::Texture2D*>(droppedAsset);

                    tileset->AddTile(texture2d);
                    tileset->Build();
                }
            }

            ImGui::EndDragDropTarget();
        }

        if (ImGui::IsItemHovered())
            ImGui::SetTooltip("Drag textures here to add them as tiles.");

        ImGui::SameLine();

        if (ImGui::Button(ICON_MD_REMOVE))
        {
            tileset->RemoveTile(*tileset->GetTileByIndex(selectedTileset));
            tileset->Build();

            selectedTileset = 0;
        }

        Widgets::TilesetAtlas(tileset, selectedTileset);

        ImGui::BeginChild("TilesetProperties", ImVec2(-1.f, 200.f), true);
        {
            static bool showCollider = false;

            if (const auto tile = tileset->GetTileByIndex(selectedTileset))
            {
                if (tile->m_Texture)
                {
                    ImGui::BeginChild("TileInfo", ImVec2(ImGui::GetContentRegionAvail().x - 110.f, ImGui::GetContentRegionAvail().y));
                    {
                        ImGui::Columns(2, nullptr, false);

                        bool noCollision = tile->m_DefaultFlags & Pine::TileFlags_NoCollision;
                        bool hidden = tile->m_DefaultFlags & Pine::TileFlags_Hidden;
                        bool custom1 = tile->m_DefaultFlags & Pine::TileFlags_Custom1;
                        bool custom2 = tile->m_DefaultFlags & Pine::TileFlags_Custom2;
                        bool custom3 = tile->m_DefaultFlags & Pine::TileFlags_Custom3;

                        ImGui::Text("Flags");

                        if (ImGui::Checkbox("No Collision", &noCollision))
                        {
                            if (noCollision)
                                tile->m_DefaultFlags |= Pine::TileFlags_NoCollision;
                            else
                                tile->m_DefaultFlags &= ~Pine::TileFlags_NoCollision;
                        }

                        if (ImGui::Checkbox("Hidden", &hidden))
                        {
                            if (hidden)
                                tile->m_DefaultFlags |= Pine::TileFlags_Hidden;
                            else
                                tile->m_DefaultFlags &= ~Pine::TileFlags_Hidden;
                        }

                        if (ImGui::Checkbox("Custom 1", &custom1))
                        {
                            if (custom1)
                                tile->m_DefaultFlags |= Pine::TileFlags_Custom1;
                            else
                                tile->m_DefaultFlags &= ~Pine::TileFlags_Custom1;
                        }

                        if (ImGui::Checkbox("Custom 2", &custom2))
                        {
                            if (custom2)
                                tile->m_DefaultFlags |= Pine::TileFlags_Custom2;
                            else
                                tile->m_DefaultFlags &= ~Pine::TileFlags_Custom2;
                        }

                        if (ImGui::Checkbox("Custom 3", &custom3))
                        {
                            if (custom3)
                                tile->m_DefaultFlags |= Pine::TileFlags_Custom3;
                            else
                                tile->m_DefaultFlags &= ~Pine::TileFlags_Custom3;
                        }

                        ImGui::NextColumn();

                        ImGui::Checkbox("Show Collider", &showCollider);

                        ImGui::Text("Collider Offset");
                        if (ImGui::DragFloat2("##ColliderOffset", &tile->m_ColliderOffset[0], 0.01f))
                        {
                            tileset->MarkAsModified();
                        }

                        ImGui::Text("Collider Size");
                        if (ImGui::DragFloat2("##ColliderSize", &tile->m_ColliderSize[0], 0.01f))
                        {
                            tileset->MarkAsModified();
                        }

                        ImGui::Text("Collider Rotation");
                        if (ImGui::DragFloat("##ColliderRotation", &tile->m_ColliderRotation, 0.1f))
                        {
                            tileset->MarkAsModified();
                        }

                        ImGui::EndColumns();
                    }
                    ImGui::EndChild();

                    ImGui::SameLine();

                    ImVec2 imageCursorPos = ImGui::GetCursorScreenPos();

                    ImGui::Image(reinterpret_cast<ImTextureID>(*static_cast<std::uint64_t*>(tile->m_Texture->GetGraphicsTexture()->GetGraphicsIdentifier())), ImVec2(100.f, 100.f));

                    // Render collider preview to the best of our ability here
                    Pine::Vector2f position = Pine::Vector2f(imageCursorPos.x, imageCursorPos.y) + (tile->m_ColliderOffset * static_cast<float>(Pine::Rendering::PixelsPerUnit));
                    Pine::Vector2f size = Pine::Vector2f(std::min(tile->m_Texture->GetWidth(), 100), std::min(tile->m_Texture->GetHeight(), 100)) * tile->m_ColliderSize;

                    if (showCollider)
                    {
                        ImGui::GetWindowDrawList()->AddRect(ImVec2(position.x, position.y), ImVec2(position.x + size.x, position.y + size.y), ImColor(0, 150, 255));
                    }
                }
            }
            else
            {
                ImGui::Text("No tile selected.");
            }
        }
        ImGui::EndChild();

        ImGui::TextDisabled("Tiles: %d", static_cast<int>(tileset->GetTileList().size()));
        ImGui::TextDisabled("Tile size: %d", tileset->GetTileSize());
    }

    void RenderTilemap(Pine::Tilemap *tilemap)
    {
        const auto newTileset = Widgets::AssetPicker("Tile-set", tilemap->GetTileset(), Pine::AssetType::Tileset);

        if (newTileset.hasResult)
        {
            tilemap->SetTileset(dynamic_cast<Pine::Tileset *>(newTileset.asset));
        }
    }

    void RenderAudioFile(Pine::AudioFile *audiofile)
    {

    }
}

void AssetPropertiesPanel::Render(Pine::IAsset *asset)
{
    auto fileIcon = IconStorage::GetIconTexture(asset->GetPath());

    ImGui::Image(reinterpret_cast<ImTextureID>(*static_cast<std::uint64_t *>(fileIcon->GetGraphicsIdentifier())), ImVec2(64.f, 64.f));

    ImGui::SameLine();

    ImGui::BeginChild("##AssetPropertiesChild", ImVec2(-1.f, 65.f), false, 0);

    auto formattedPath = "/" + std::filesystem::path(asset->GetPath()).string();

    ImGui::Text("%s", asset->GetFileName().c_str());
    ImGui::Text("%s", formattedPath.c_str());

    ImGui::Text("%s", AssetTypeToString(asset->GetType()));

    ImGui::EndChild();

    ImGui::Spacing();
    ImGui::Separator();
    ImGui::Spacing();

    switch (asset->GetType())
    {
        case Pine::AssetType::Texture2D:
            RenderTexture2D(dynamic_cast<Pine::Texture2D *>(asset));
            break;
        case Pine::AssetType::Texture3D:
            RenderTexture3D(dynamic_cast<Pine::Texture3D *>(asset));
            break;
        case Pine::AssetType::Shader:
            RenderShader(dynamic_cast<Pine::Shader *>(asset));
            break;
        case Pine::AssetType::Material:
            RenderMaterial(dynamic_cast<Pine::Material *>(asset));
            break;
        case Pine::AssetType::Model:
            RenderModel(dynamic_cast<Pine::Model *>(asset));
            break;
        case Pine::AssetType::Blueprint:
            RenderBlueprint(dynamic_cast<Pine::Blueprint *>(asset));
            break;
        case Pine::AssetType::Level:
            RenderLevel(dynamic_cast<Pine::Level *>(asset));
            break;
        case Pine::AssetType::Tileset:
            RenderTileset(dynamic_cast<Pine::Tileset *>(asset));
            break;
        case Pine::AssetType::Tilemap:
            RenderTilemap(dynamic_cast<Pine::Tilemap *>(asset));
            break;
        case Pine::AssetType::Audio:
            RenderAudioFile(dynamic_cast<Pine::AudioFile *>(asset));
            break;
        default:
            ImGui::Text("No asset properties available.");
            break;
    }

    /*

    ImGui::Spacing();
    ImGui::Separator();
    ImGui::Spacing();

    if (ImGui::Button("Open File", ImVec2(100.f, 30.f)))
    {

    }

    ImGui::SameLine();

    if (ImGui::Button("Remove", ImVec2(100.f, 30.f)))
    {
        std::filesystem::remove(asset->GetFilePath());

        Selection::Clear();

        Panels::AssetBrowser::RebuildAssetTree();
    }
    */
}